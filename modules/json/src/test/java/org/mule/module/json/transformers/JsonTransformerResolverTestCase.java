/*
 * Copyright (c) MuleSoft, Inc.  All rights reserved.  http://www.mulesoft.com
 * The software in this package is published under the terms of the CPAL v1.0
 * license, a copy of which has been included with this distribution in the
 * LICENSE.txt file.
 */
package org.mule.module.json.transformers;

import static org.hamcrest.Matchers.containsString;
import static org.hamcrest.Matchers.equalTo;
import static org.hamcrest.Matchers.greaterThan;
import static org.hamcrest.Matchers.nullValue;
import static org.hamcrest.Matchers.sameInstance;
import static org.junit.Assert.assertThat;
import static org.mule.transformer.types.MimeTypes.APPLICATION_JSON;

import org.mule.api.transformer.DataType;
import org.mule.api.transformer.Transformer;
import org.mule.api.transformer.TransformerException;
import org.mule.json.model.Item;
import org.mule.tck.junit4.FunctionalTestCase;
import org.mule.transformer.types.SimpleDataType;

import java.util.List;

import org.junit.Test;

public class JsonTransformerResolverTestCase extends FunctionalTestCase
{
    @Override
    protected String getConfigFile()
    {
        return "json-transformer-resolver-config.xml";
    }

    @Test
    public void doesNotLeakTransformers() throws Exception
    {
        DataType source = new SimpleDataType(Item.class, APPLICATION_JSON);
        DataType target = DataType.STRING_DATA_TYPE;

        // An empty uninitialized transformer is automatically added for each transformer entry in the XML
        assertThat(numberOfTransformersFor(source, target), greaterThan(0));
        AbstractJsonTransformer autoGeneratedJsonTransformer = (AbstractJsonTransformer) existingTransformersFor(source, target).get(0);
        assertThat(autoGeneratedJsonTransformer.getMapper(), nullValue());

        // The first time it will be created
        clearTransformerCache();
        ObjectToJson transformer = (ObjectToJson) createOrGetTransformerFor(source, target);
        int numberOfTransformers = numberOfTransformersFor(source, target);

        // The second time it should be returned again and no others should be added
        clearTransformerCache();
        assertThat(createOrGetTransformerFor(source, target), sameInstance((Transformer) transformer));
        assertThat(numberOfTransformersFor(source, target), equalTo(numberOfTransformers));

        // Make sure the transformer actually works; if the uninitialized one was returned this will result in an exception
        Item item = new Item();
        item.setCode("123");
        item.setDescription("ABC");
        item.setInStock(true);
        String result = (String) transformer.transform(item);
        assertThat(result, containsString("123"));
        assertThat(result, containsString("ABC"));
    }

    private void clearTransformerCache()
    {
        // We use dispose() to clear the cache, to force the registry to call JsonTransformerResolver again instead of doing nothing
        muleContext.getRegistry().dispose();
    }

    private Transformer createOrGetTransformerFor(DataType source, DataType target) throws TransformerException
    {
        return muleContext.getRegistry().lookupTransformer(source, target);
    }

    private List<Transformer> existingTransformersFor(DataType source, DataType target)
    {
        return muleContext.getRegistry().lookupTransformers(source, target);
    }

    private int numberOfTransformersFor(DataType source, DataType target)
    {
        return existingTransformersFor(source, target).size();
    }
}
