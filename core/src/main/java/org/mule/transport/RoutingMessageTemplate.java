package org.mule.transport;

import org.mule.MessageExchangePattern;
import org.mule.OptimizedRequestContext;
import org.mule.ResponseOutputStream;
import org.mule.VoidMuleEvent;
import org.mule.api.MuleEvent;
import org.mule.api.MuleException;
import org.mule.api.MuleMessage;
import org.mule.api.MuleSession;
import org.mule.api.config.MuleProperties;
import org.mule.api.processor.MessageProcessor;
import org.mule.api.routing.filter.FilterUnacceptedException;
import org.mule.api.transport.PropertyScope;
import org.mule.api.transport.SessionHandler;
import org.mule.session.DefaultMuleSession;
import org.mule.session.LegacySessionHandler;
import org.mule.util.ObjectUtils;

import java.io.OutputStream;

import org.apache.commons.lang.SerializationException;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;


public abstract class RoutingMessageTemplate
{

    protected transient Log logger = LogFactory.getLog(getClass());

    protected MessageProcessor listener;
    protected MessageExchangePattern exchangePattern;
    protected SessionHandler sessionHandler;

    protected RoutingMessageTemplate(MessageProcessor listener, MessageExchangePattern exchangePattern, SessionHandler sessionHandler)
    {
        this.listener = listener;
        this.exchangePattern = exchangePattern;
        this.sessionHandler = sessionHandler;
    }

    public MuleEvent routeEvent(MuleEvent originalEvent, OutputStream outputStream)
            throws MuleException
    {
        return routeMessage(originalEvent.getMessage(), outputStream);
    }

    protected abstract void applyInboundTransformers(MuleEvent muleEvent) throws MuleException;

    protected abstract MuleEvent doCreateEvent(MuleMessage message, ResponseOutputStream ros, MuleSession session);

    protected abstract void fireResponseNotification(MuleEvent resultEvent);

    protected abstract void applyResponseTransformers(MuleEvent resultEvent) throws MuleException;


    protected MuleEvent routeMessage(MuleMessage message, OutputStream outputStream)
            throws MuleException
    {

        warnIfMuleClientSendUsed(message);

        propagateRootMessageIdProperty(message);

        MuleEvent muleEvent = createMuleEvent(message, outputStream);

        applyInboundTransformers(muleEvent);

        return routeEvent(muleEvent);
    }


    protected void warnIfMuleClientSendUsed(MuleMessage message)
    {
        final Object remoteSyncProperty = message.removeProperty(MuleProperties.MULE_REMOTE_SYNC_PROPERTY,
                                                                 PropertyScope.INBOUND);
        if (ObjectUtils.getBoolean(remoteSyncProperty, false) && !exchangePattern.hasResponse())
        {
            logger.warn("MuleClient.send() was used but the receiver  "
                        + " is not 'request-response'.  No response will be returned.");
        }

        message.removeProperty(MuleProperties.MULE_REMOTE_SYNC_PROPERTY, PropertyScope.INBOUND);
    }


    protected void propagateRootMessageIdProperty(MuleMessage message)
    {
        String rootId = message.getInboundProperty(MuleProperties.MULE_ROOT_MESSAGE_ID_PROPERTY);
        if (rootId != null)
        {
            message.setMessageRootId(rootId);
            message.removeProperty(MuleProperties.MULE_ROOT_MESSAGE_ID_PROPERTY, PropertyScope.INBOUND);
        }
    }

    protected MuleEvent createMuleEvent(MuleMessage message, OutputStream outputStream)
            throws MuleException
    {
        ResponseOutputStream ros = getResponseOutputStream(outputStream);
        MuleSession session = getMuleSession(message);
        MuleEvent event = doCreateEvent(message, ros, session);
        event = OptimizedRequestContext.unsafeSetEvent(event);
        handleAuthentication(session, event);

        return event;
    }

    private void handleAuthentication(MuleSession session, MuleEvent event)
    {
        if (session.getSecurityContext() != null && session.getSecurityContext().getAuthentication() != null)
        {
            session.getSecurityContext().getAuthentication().setEvent(event);
        }
    }

    private ResponseOutputStream getResponseOutputStream(OutputStream outputStream)
    {
        ResponseOutputStream ros = null;
        if (outputStream != null)
        {
            if (outputStream instanceof ResponseOutputStream)
            {
                ros = (ResponseOutputStream) outputStream;
            }
            else
            {
                ros = new ResponseOutputStream(outputStream);
            }
        }
        return ros;
    }

    protected MuleSession getMuleSession(MuleMessage message) throws MuleException
    {
        MuleSession session;
        try
        {
            session = sessionHandler.retrieveSessionInfoFromMessage(message);
        }
        catch (SerializationException se)
        {
            try
            {
                // EE-1820 Support message headers generated by previous Mule versions
                session = new LegacySessionHandler().retrieveSessionInfoFromMessage(message);
            }
            catch (Exception e)
            {
                // If the LegacySessionHandler didn't work either, just bubble up the original SerializationException (see MULE-5487)
                throw se;
            }
        }
        if (session == null)
        {
            session = new DefaultMuleSession();
        }
        return session;
    }

    protected MuleEvent routeEvent(MuleEvent muleEvent) throws MuleException
    {
        MuleEvent resultEvent = listener.process(muleEvent);
        if (isUnaccepted(resultEvent))
        {
            handleUnacceptedFilter(muleEvent.getMessage());
            return muleEvent;
        }

        return handleResponse(resultEvent);
    }

    protected MuleEvent handleResponse(MuleEvent resultEvent) throws MuleException
    {
        if (exchangePattern.hasResponse() && resultEvent != null
            && !VoidMuleEvent.getInstance().equals(resultEvent))
        {
            // Do not propagate security context back to caller
            MuleSession resultSession = new DefaultMuleSession(resultEvent.getSession());
            resultSession.setSecurityContext(null);
            sessionHandler.storeSessionInfoToMessage(resultSession, resultEvent.getMessage());

            applyResponseTransformers(resultEvent);

            fireResponseNotification(resultEvent);

            return resultEvent;
        }
        else
        {
            return null;
        }
    }

    private boolean isUnaccepted(MuleEvent resultEvent)
    {
        return resultEvent != null
               && !VoidMuleEvent.getInstance().equals(resultEvent)
               && resultEvent.getMessage() != null
               && resultEvent.getMessage().getExceptionPayload() != null
               && resultEvent.getMessage().getExceptionPayload().getException() instanceof FilterUnacceptedException;
    }

    protected MuleMessage handleUnacceptedFilter(MuleMessage message)
    {
        if (logger.isDebugEnabled())
        {
            String messageId = message.getUniqueId();
            logger.debug("Message " + messageId + " failed to pass filter for message " + messageId
                         + ". Message is being ignored");
        }
        return message;
    }


}
