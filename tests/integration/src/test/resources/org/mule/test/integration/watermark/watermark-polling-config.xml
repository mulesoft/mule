<?xml version="1.0" encoding="utf-8"?>

<mule xmlns="http://www.mulesoft.org/schema/mule/core"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xmlns:spring="http://www.springframework.org/schema/beans"
      xmlns:doc="http://www.mulesoft.org/schema/mule/documentation"
      xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
               http://www.mulesoft.org/schema/mule/core http://www.mulesoft.org/schema/mule/core/current/mule.xsd
               ">

    <flow name="echo">
        <static-component>
            <return-data>foo</return-data>
        </static-component>
    </flow>
    
    <sub-flow name="fruits">
    	<set-payload value="#[mel:['Apple', 'Banana', 'Coconut']]" />
    </sub-flow>
    
    <sub-flow name="fruitsIterator">
    	<flow-ref name="fruits" />
    	<set-payload value="#[mel:payload.iterator()]" />
    </sub-flow>
    
    <flow name="pollWithoutWatermark" initialState="stopped">
        <poll frequency="1000">
            <processor-chain>
                <set-payload value="pollWithoutWatermark"/>
                <flow-ref name="echo"/>
            </processor-chain>
        </poll>
        <component class="org.mule.test.integration.watermark.WatermarkPollingTestCase$FooComponent"/>
    </flow>

    <flow name="nameNotDefinedWatermarkObjectStoreFlow" processingStrategy="synchronous" initialState="stopped">
        <poll frequency="1000">
            <watermark variable="test1" default-expression="#[mel:'noKey']"/>
            <flow-ref name="echo"/>
        </poll>
        <logger message="Executed With watermark"/>
    </flow>

    <flow name="changeWatermarkWihtNotDefinedWatermarkObjectStoreFlow" processingStrategy="synchronous" initialState="stopped">
        <poll frequency="1000">
            <watermark variable="test2" default-expression="#[mel:'noKey']"/>
            <flow-ref name="echo"/>
        </poll>
        <set-variable variableName="test2" value="keyPresent"/>
        <logger level="ERROR" message="Executed With watermark #[mel:test2]"/>
    </flow>


    <flow name="usingWatermarkFlow" processingStrategy="synchronous" initialState="stopped">
        <poll frequency="1000">
            <watermark variable="test3" default-expression="#[mel:'noKey']"/>
            <flow-ref name="echo"/>
        </poll>
        <set-payload value="#[mel:test3]"/>
        <set-variable variableName="test3" value="keyPresent"/>
        <component class="org.mule.test.integration.watermark.WatermarkPollingTestCase$FooComponent"/>
    </flow>


    <flow name="usingWatermarkFlowWithNullValue" processingStrategy="synchronous" initialState="stopped">
        <poll frequency="1000">
            <watermark variable="testNull" default-expression="#[mel:null]" update-expression="#[mel:'noWatermark']"/>
            <flow-ref name="echo"/>
        </poll>
        <choice>
            <when expression="#[mel:testNull != null]">
                <set-payload value="#[mel:testNull]"/>
                <component class="org.mule.test.integration.watermark.WatermarkPollingTestCase$FooComponent"/>
            </when>
            <otherwise>
                <logger level="ERROR" message="Watermark value is null as expected"/>
            </otherwise>
        </choice>

    </flow>

    <flow name="usingWatermarkFlowWithNullUpdateValue" processingStrategy="synchronous" initialState="stopped">
        <poll frequency="1000">
            <watermark variable="testUpdateAsNull" default-expression="#[mel:'defaultValue']" update-expression="#[mel:null]"/>
            <flow-ref name="echo"/>
        </poll>

        <set-payload value="#[mel:testUpdateAsNull]"/>
        <component class="org.mule.test.integration.watermark.WatermarkPollingTestCase$FooComponent"/>
    </flow>

    <flow name="watermarkWithKeyAsAnExpression" processingStrategy="synchronous" initialState="stopped">
        <poll frequency="1000">
            <watermark variable="#[mel:'test4']" default-expression="#[mel:'noKey']"/>
            <flow-ref name="echo"/>
        </poll>
        <set-variable variableName="test4" value="keyPresent"/>
    </flow>


    <flow name="watermarkWithUpdateExpression" processingStrategy="synchronous" initialState="stopped">
        <poll frequency="1000">
            <watermark variable="test5" default-expression="#[mel:'noKey']" update-expression="#[mel:payload]"/>
            <flow-ref name="echo"/>
        </poll>
        <set-payload value="#[mel:'valueUpdated']"/>
        <set-variable variableName="test5" value="keyPresent"/>
        <component class="org.mule.test.integration.watermark.WatermarkPollingTestCase$FooComponent"/>
    </flow>


    <flow name="watermarkWithAnnotations" processingStrategy="synchronous" initialState="stopped">
        <poll frequency="1000">
            <watermark variable="test6" default-expression="#[mel:'noKey']" doc:name="watermark"/>
            <flow-ref name="echo"/>
        </poll>
        <set-payload value="#[mel:'valueUpdated']"/>
    </flow>

    <flow name="watermarkWithAsyncProcessing" initialState="stopped">
        <poll frequency="1000">
            <watermark variable="test6" default-expression="#[mel:'noKey']"/>
            <flow-ref name="echo"/>
        </poll>
        <set-payload value="#[mel:'valueUpdated']"/>
        <set-variable variableName="test6" value="keyPresent"/>
        <component class="org.mule.test.integration.watermark.WatermarkPollingTestCase$FooComponent"/>
    </flow>

    <flow name="watermarkWithObjectStore" processingStrategy="synchronous" initialState="stopped">
        <poll frequency="1000">
            <watermark variable="test8" default-expression="#[mel:'noKey']" update-expression="#[mel:payload]" object-store-ref="_defaultInMemoryObjectStore"/>
            <flow-ref name="echo"/>
        </poll>
        <set-payload value="#[mel:'valueUpdated']"/>
        <set-variable variableName="test8" value="keyPresent"/>
        <component class="org.mule.test.integration.watermark.WatermarkPollingTestCase$FooComponent"/>
    </flow>

    <flow name="failingFlowWithWatermark" processingStrategy="synchronous" initialState="stopped">
        <poll frequency="1000">
            <watermark variable="test6" default-expression="#[mel:'noKey']" update-expression="#[mel:payload]"/>
            <flow-ref name="echo"/>
        </poll>
        <set-payload value="#[mel:'valueUpdated']"/>
        <set-payload value="#[mel:sing:valueU]"/>
        <set-variable variableName="test6" value="keyPresent"/>
        <component class="org.mule.test.integration.watermark.WatermarkPollingTestCase$FooComponent"/>
    </flow>

    <flow name="failingFlowCachedExceptionWatermark" processingStrategy="synchronous" initialState="stopped">
        <poll frequency="1000">
            <watermark variable="test7" default-expression="#[mel:'noKey']"/>
            <flow-ref name="echo"/>
        </poll>
        <set-payload value="#[mel:sing:valueU]"/>
        <component class="org.mule.test.integration.watermark.WatermarkPollingTestCase$FooComponent"/>
        <error-handler>
            <on-error-continue>
                <logger level="ERROR" message="'FAILED'"/>
                <set-variable variableName="test7" value="catchedException"/>
                <logger level="ERROR" message="#[mel:test7]"/>
            </on-error-continue>
        </error-handler>

    </flow>

	<flow name="minSelectorWithList" processingStrategy="synchronous" initialState="stopped">
		<poll frequency="1000">
            <watermark variable="minSelectorWithList" default-expression="#[mel:'noKey']" selector="MIN" selector-expression="#[mel:payload.charAt(0)]"/>
    		<flow-ref name="fruits" />
        </poll>
        
        <flow-ref name="consume" />
	</flow>
	
	<flow name="maxSelectorWithList" processingStrategy="synchronous" initialState="stopped">
		<poll frequency="1000">
            <watermark variable="maxSelectorWithList" default-expression="#[mel:'noKey']" selector="MAX" selector-expression="#[mel:payload.charAt(0)]"/>
    		<flow-ref name="fruits" />
        </poll>
        
        <flow-ref name="consume" />
	</flow>
	
	<flow name="firstSelectorWithList" processingStrategy="synchronous" initialState="stopped">
		<poll frequency="1000">
            <watermark variable="firstSelectorWithList" default-expression="#[mel:'noKey']" selector="FIRST" />
    		<flow-ref name="fruits" />
        </poll>
        
        <flow-ref name="consume" />
	</flow>
	
	<flow name="lastSelectorWithList" processingStrategy="synchronous" initialState="stopped">
		<poll frequency="1000">
            <watermark variable="lastSelectorWithList" default-expression="#[mel:'noKey']" selector="LAST" />
    		<flow-ref name="fruits" />
        </poll>
        
        <flow-ref name="consume" />
	</flow>
	
	<flow name="minSelectorWithIterator" processingStrategy="synchronous" initialState="stopped">
		<poll frequency="1000">
            <watermark variable="minSelectorWithIterator" default-expression="#[mel:'noKey']" selector="MIN" selector-expression="#[mel:payload.charAt(0)]"/>
    		<flow-ref name="fruitsIterator" />
        </poll>
        
        <flow-ref name="consume" />
	</flow>
	
	<flow name="maxSelectorWithIterator" processingStrategy="synchronous" initialState="stopped">
		<poll frequency="1000">
            <watermark variable="maxSelectorWithIterator" default-expression="#[mel:'noKey']" selector="MAX" selector-expression="#[mel:payload.charAt(0)]"/>
    		<flow-ref name="fruitsIterator" />
        </poll>
        
        <flow-ref name="consume" />
	</flow>
	
	<flow name="firstSelectorWithIterator" processingStrategy="synchronous" initialState="stopped">
		<poll frequency="1000">
            <watermark variable="firstSelectorWithIterator" default-expression="#[mel:'noKey']" selector="FIRST" />
    		<flow-ref name="fruitsIterator" />
        </poll>
        
        <flow-ref name="consume" />
	</flow>
	
	<flow name="lastSelectorWithIterator" processingStrategy="synchronous" initialState="stopped">
		<poll frequency="1000">
            <watermark variable="lastSelectorWithIterator" default-expression="#[mel:'noKey']" selector="LAST" />
    		<flow-ref name="fruitsIterator" />
        </poll>
        
        <flow-ref name="consume" />
	</flow>
	
	<sub-flow name="consume">
		<foreach>
			<logger message="selecting from #[mel:payload]" />
		</foreach>
	</sub-flow>

</mule>
