/*
 * Copyright (c) MuleSoft, Inc.  All rights reserved.  http://www.mulesoft.com
 * The software in this package is published under the terms of the CPAL v1.0
 * license, a copy of which has been included with this distribution in the
 * LICENSE.txt file.
 */
package org.mule.extension.db.internal.operation;

import static java.lang.String.format;
import static java.util.Arrays.asList;
import static java.util.stream.Collectors.toSet;
import static org.apache.commons.collections.CollectionUtils.isEmpty;
import static org.slf4j.LoggerFactory.getLogger;
import org.mule.extension.db.api.StatementResult;
import org.mule.extension.db.api.param.ParameterType;
import org.mule.extension.db.api.param.ParameterizedStatementDefinition;
import org.mule.extension.db.api.param.QueryDefinition;
import org.mule.extension.db.api.param.QuerySettings;
import org.mule.extension.db.internal.DbConnector;
import org.mule.extension.db.internal.domain.autogeneratedkey.AutoGenerateKeysStrategy;
import org.mule.extension.db.internal.domain.autogeneratedkey.ColumnIndexAutoGenerateKeysStrategy;
import org.mule.extension.db.internal.domain.autogeneratedkey.ColumnNameAutoGenerateKeysStrategy;
import org.mule.extension.db.internal.domain.autogeneratedkey.DefaultAutoGenerateKeysStrategy;
import org.mule.extension.db.internal.domain.autogeneratedkey.NoAutoGenerateKeysStrategy;
import org.mule.extension.db.internal.domain.connection.DbConnection;
import org.mule.extension.db.internal.domain.executor.UpdateExecutor;
import org.mule.extension.db.internal.domain.param.QueryParam;
import org.mule.extension.db.internal.domain.query.Query;
import org.mule.extension.db.internal.domain.query.QueryTemplate;
import org.mule.extension.db.internal.domain.query.QueryType;
import org.mule.extension.db.internal.domain.statement.QueryStatementFactory;
import org.mule.extension.db.internal.resolver.query.ParameterizedQueryResolver;
import org.mule.extension.db.internal.resolver.query.QueryResolver;

import com.google.common.base.Joiner;

import java.sql.SQLException;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import org.slf4j.Logger;

/**
 * Base class with common functionality for Database operations
 *
 * @since 4.0
 */
abstract class BaseDbOperations {

  private static final Logger LOGGER = getLogger(DmlOperations.class);
  protected static final int DEFAULT_FETCH_SIZE = 10;
  protected static final String QUERY_GROUP = "Query";
  protected static final String QUERY_SETTINGS = "Query Settings";

  protected final QueryResolver<ParameterizedStatementDefinition> queryResolver = new ParameterizedQueryResolver<>();

  protected QueryStatementFactory getStatementFactory(boolean streaming,
                                                      QuerySettings settings) {

    QueryStatementFactory statementFactory = new QueryStatementFactory();

    if (settings.getMaxRows() != null) {
      statementFactory.setMaxRows(settings.getMaxRows());
    }

    if (settings.getFetchSize() != null) {
      statementFactory.setFetchSize(settings.getFetchSize());
    } else if (streaming) {
      LOGGER.warn("Streaming mode needs to configure fetchSize property. Using default value: " + DEFAULT_FETCH_SIZE);
      statementFactory.setFetchSize(DEFAULT_FETCH_SIZE);
    }


    statementFactory.setQueryTimeout(new Long(settings.getQueryTimeoutUnit().toSeconds(settings.getQueryTimeout())).intValue());

    return statementFactory;
  }

  protected StatementResult executeUpdate(QueryDefinition query,
                                          AutoGenerateKeysAttributes autoGenerateKeysAttributes,
                                          DbConnection connection,
                                          Query resolvedQuery)
      throws SQLException {
    QueryStatementFactory statementFactory = getStatementFactory(false, query);
    return (StatementResult) new UpdateExecutor(statementFactory)
        .execute(connection, resolvedQuery, getAutoGeneratedKeysStrategy(autoGenerateKeysAttributes));
  }

  protected Query resolveQuery(QueryDefinition query, DbConnector connector, DbConnection connection, QueryType... validTypes) {
    final Query resolvedQuery = queryResolver.resolve(query, connector, connection);
    validateQueryType(resolvedQuery.getQueryTemplate(), asList(validTypes));
    validateNoParameterTypeIsUnused(resolvedQuery, query.getParameterTypes());
    return resolvedQuery;
  }

  protected void validateQueryType(QueryTemplate queryTemplate, List<QueryType> validTypes) {
    if (validTypes == null || !validTypes.contains(queryTemplate.getType())) {
      throw new IllegalArgumentException(format("Query type must be one of [%s] but query '%s' is of type '%s'",
                                                Joiner.on(", ").join(validTypes), queryTemplate.getSqlText(),
                                                queryTemplate.getType()));
    }
  }


  protected void validateNoParameterTypeIsUnused(Query query, List<ParameterType> parameterTypes) {
    Set<String> params = query.getQueryTemplate().getParams().stream().map(QueryParam::getName).collect(toSet());
    Set<String> unusedTypes =
        parameterTypes.stream().map(type -> type.getKey()).filter(type -> !params.contains(type)).collect(toSet());

    if (!unusedTypes.isEmpty()) {
      throw new IllegalArgumentException(format("Query defines parameters [%s] but they aren't present in the query",
                                                Joiner.on(", ").join(unusedTypes.stream()
                                                    .map(s -> new StringBuilder().append("'").append(s).append("'").toString())
                                                    .collect(Collectors.toList()))));

    }
  }

  protected AutoGenerateKeysStrategy getAutoGeneratedKeysStrategy(AutoGenerateKeysAttributes keyAttributes) {

    if (keyAttributes == null) {
      return new NoAutoGenerateKeysStrategy();
    }

    if (keyAttributes.isAutoGenerateKeys()) {

      final List<Integer> columnIndexes = keyAttributes.getAutoGeneratedKeysColumnIndexes();
      final List<String> columnNames = keyAttributes.getAutoGeneratedKeysColumnNames();

      if (!isEmpty(columnIndexes)) {
        int[] indexes = new int[columnIndexes.size()];
        int i = 0;
        for (int index : columnIndexes) {
          indexes[i++] = index;
        }
        return new ColumnIndexAutoGenerateKeysStrategy(indexes);
      } else if (!isEmpty(columnNames)) {
        return new ColumnNameAutoGenerateKeysStrategy(columnNames.stream().toArray(String[]::new));
      } else {
        return new DefaultAutoGenerateKeysStrategy();
      }
    } else {
      return new NoAutoGenerateKeysStrategy();
    }
  }
}
